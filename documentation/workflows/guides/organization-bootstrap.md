---
status: current
last_updated: 2026-02-10
---

<!-- TL;DR-START -->
## TL;DR

**Summary**: Complete guide to the organization bootstrap workflow - orchestrates organization provisioning with contacts/addresses/phones/emails, provider_admin role with 27 permissions, optional DNS CNAME creation (7 retry attempts), secure invitation generation, and email delivery via Resend. Implements Saga pattern with reverse-order compensation (revoke invitations → remove DNS → delete entities → deactivate org). All state changes emit domain events with workflow correlation_id. Safety net: deactivateOrganization provides CQRS-compliant direct-write fallback when event emission fails.

**When to read**:
- Implementing organization onboarding features
- Understanding the bootstrap workflow lifecycle
- Debugging organization creation failures
- Adding new provisioning steps
- Understanding Saga compensation flow

**Prerequisites**: [temporal-overview](../../architecture/workflows/temporal-overview.md), [error-handling-and-compensation](./error-handling-and-compensation.md)

**Key topics**: `organization-bootstrap`, `saga-compensation`, `dns-provisioning`, `invitation-workflow`, `event-driven-provisioning`, `rbac-bootstrap`, `idempotency`

**Estimated read time**: 30 minutes (full), 10 minutes (forward flow only)
<!-- TL;DR-END -->

# Organization Bootstrap Workflow

**Status**: ✅ Production workflow (deployed)
**Purpose**: Orchestrate complete organization provisioning from creation to activation
**Pattern**: Workflow-First with Saga compensation for rollback

---

## Table of Contents

1. [Overview](#overview)
2. [Workflow Phases](#workflow-phases)
3. [Input Parameters](#input-parameters)
4. [Output Result](#output-result)
5. [Forward Flow (Success Path)](#forward-flow-success-path)
6. [Compensation Flow (Failure Path)](#compensation-flow-failure-path)
7. [Domain Events Emitted](#domain-events-emitted)
8. [Activity Details](#activity-details)
9. [Idempotency Strategy](#idempotency-strategy)
10. [DNS Retry Strategy](#dns-retry-strategy)
11. [Safety Net Pattern](#safety-net-pattern)
12. [Error Handling](#error-handling)
13. [Example Usage](#example-usage)
14. [Related Documentation](#related-documentation)

---

## Overview

The organization bootstrap workflow orchestrates the complete provisioning of a new organization in the A4C Platform. It handles:

- Organization record creation with contacts, addresses, phones, and emails
- Provider admin role creation and permission grants (27 canonical permissions)
- Conditional DNS CNAME record provisioning (for providers and VAR partners)
- DNS propagation verification with multi-server quorum
- User invitation generation with secure tokens
- Invitation email delivery via Resend (primary) or SMTP (fallback)
- Organization activation on success
- Saga compensation rollback on failure

**Key Characteristics**:
- **Durable**: Survives worker crashes and restarts
- **Idempotent**: Safe to retry at workflow and activity levels
- **Event-driven**: All state changes emit domain events for audit trail
- **Compensating**: Automatic rollback in reverse order on failure
- **Traceable**: Full correlation via `tracing.correlationId` from API layer

---

## Workflow Phases

The bootstrap workflow executes 5 sequential phases:

| Phase | Purpose | Activities | Events | Conditional |
|-------|---------|------------|--------|-------------|
| **1. Organization Creation** | Create org record with contacts | `createOrganization` | `organization.created`, `contact.created`, `address.created`, `phone.created`, `email.created`, `organization.*.linked` | Always |
| **1.5. Permission Grant** | Create provider_admin role | `grantProviderAdminPermissions` | `role.created`, `role.permission.granted` (×27) | Always |
| **2. DNS Provisioning** | Configure subdomain CNAME | `configureDNS`, `verifyDNS` | `organization.subdomain.dns_created`, `organization.subdomain.verified` | If subdomain provided |
| **3. Invitation Generation** | Generate secure tokens | `generateInvitations` | `user.invited` | Always |
| **4. Email Delivery** | Send invitation emails | `sendInvitationEmails` | `user.invitation.sent` | Always |
| **5. Activation** | Mark organization active | `emitBootstrapCompletedActivity` | `organization.bootstrap.completed` | Always |

**Phase Progression**: Each phase must complete successfully before the next begins. If any phase fails, the workflow enters the compensation flow.

---

## Input Parameters

```typescript
interface OrganizationBootstrapParams {
  // Organization Identification (pre-generated by API layer)
  organizationId: string                // Pre-generated UUID for status polling

  // Organization Data
  orgData: {
    name: string                        // Display name (e.g., "ACME Health")
    type: 'provider' | 'provider_partner' | 'platform_owner'
    parentOrgId?: string                // Required for partners
    partnerType?: 'var' | 'family' | 'court'  // Required if type=provider_partner
    referringPartnerId?: string         // VAR partner who referred this org

    // Contacts (legacy mode) - deprecated, use bootstrap arrays
    contacts: Array<{
      firstName: string
      lastName: string
      email: string
      type: 'a4c_admin' | 'billing' | 'technical' | 'executive'
      label: string                     // e.g., "Primary Contact"
      title?: string
      department?: string
    }>

    // Addresses (legacy mode)
    addresses: Array<{
      street1: string
      street2?: string
      city: string
      state: string
      zipCode: string
      type: 'physical' | 'mailing'
      label: string
    }>

    // Phones (legacy mode)
    phones: Array<{
      number: string
      extension?: string
      type: 'office' | 'mobile' | 'fax'
      label: string
    }>

    // Bootstrap arrays (preferred mode - supports contact correlation)
    bootstrapContacts?: Array<{
      temp_id: string                   // Correlation key (e.g., "contact-1")
      first_name: string
      last_name: string
      email?: string                    // Optional for contacts
      type: 'a4c_admin' | 'billing' | 'technical' | 'executive'
      label: string
      title?: string
      department?: string
    }>

    bootstrapPhones?: Array<{
      temp_id: string
      number: string
      extension?: string
      type: 'office' | 'mobile' | 'fax'
      label: string
      contact_ref?: string              // Links to bootstrapContacts.temp_id
    }>

    bootstrapEmails?: Array<{
      temp_id: string
      address: string
      type: 'work' | 'personal' | 'other'
      label: string
      contact_ref?: string
    }>

    bootstrapAddresses?: Array<{
      temp_id: string
      street1: string
      street2?: string
      city: string
      state: string
      zip_code: string
      type: 'physical' | 'mailing'
      label: string
      contact_ref?: string
    }>
  }

  // DNS Configuration (conditional)
  subdomain?: string                    // Required for providers/VAR partners
  retryConfig?: {                       // Optional DNS retry override
    baseDelayMs?: number                // Default: 10000 (10s)
    maxDelayMs?: number                 // Default: 300000 (5m)
    maxAttempts?: number                // Default: 7
  }

  // User Invitations
  users: Array<{
    email: string
    firstName: string
    lastName: string
    role: string                        // Role name (e.g., "provider_admin")
  }>

  // Frontend Configuration
  frontendUrl?: string                  // Base URL for invitation links

  // Tracing Context (from API layer)
  tracing?: {
    correlationId: string               // Business transaction ID
    traceId: string                     // Request trace ID
    spanId?: string                     // Current span ID
  }
}
```

**Input Validation**:
- `orgData.contacts` or `bootstrapContacts` must have at least one contact
- `users` must have at least one user
- `subdomain` required if `orgData.type` is `provider` or `partnerType` is `var`
- `organizationId` must be a valid UUID (pre-generated by API)

---

## Output Result

```typescript
interface OrganizationBootstrapResult {
  orgId: string                         // Created organization UUID
  domain: string                        // Full domain (e.g., "acme.firstovertheline.com")
  dnsConfigured: boolean                // Whether DNS was successfully configured
  invitationsSent: number               // Count of successfully sent emails
  errors: string[]                      // Non-fatal errors (email failures, compensation errors)
}
```

**Success Result**:
```typescript
{
  orgId: "550e8400-e29b-41d4-a716-446655440000",
  domain: "acme-health.firstovertheline.com",
  dnsConfigured: true,
  invitationsSent: 2,
  errors: []
}
```

**Failure Result** (after compensation):
```typescript
{
  orgId: "550e8400-e29b-41d4-a716-446655440000",
  domain: "",
  dnsConfigured: false,
  invitationsSent: 0,
  errors: [
    "Workflow failed: DNS configuration failed after 7 attempts",
    "Failed to revoke invitations: Connection timeout"
  ]
}
```

---

## Forward Flow (Success Path)

### Phase 1: Create Organization

**Activity**: `createOrganization`

**Actions**:
1. Check if organization exists by subdomain or name (idempotency)
2. If exists, return existing org ID
3. If not exists:
   - Emit `organization.created` event (handler creates record in `organizations_projection`)
   - For each contact: emit `contact.created` + `organization.contact.linked`
   - For each phone: emit `phone.created` + `organization.phone.linked` + optional `contact.phone.linked`
   - For each email: emit `email.created` + `organization.email.linked` + optional `contact.email.linked`
   - For each address: emit `address.created` + `organization.address.linked` + optional `contact.address.linked`

**Events Emitted** (per organization):
- `organization.created` (1)
- `contact.created` (1-N)
- `phone.created` (0-N)
- `email.created` (0-N)
- `address.created` (0-N)
- `organization.contact.linked` (1-N)
- `organization.phone.linked` (0-N)
- `organization.email.linked` (0-N)
- `organization.address.linked` (0-N)
- `contact.phone.linked` (0-N, if contact_ref provided)
- `contact.email.linked` (0-N, if contact_ref provided)
- `contact.address.linked` (0-N, if contact_ref provided)

**Returns**: `{ orgId: string, contactsByEmail: Record<string, string> }`

---

### Phase 1.5: Grant Provider Admin Permissions

**Activity**: `grantProviderAdminPermissions`

**Actions**:
1. Query database for existing `provider_admin` role (via RPC `get_role_by_name_and_org`)
2. If role doesn't exist:
   - Emit `role.created` event with scope `ORGANIZATION` and `org_hierarchy_scope = subdomain`
3. Query permission templates from `role_permission_templates` table (via RPC `get_role_permission_templates`)
4. Query existing permissions for role (via RPC `get_role_permission_names`)
5. For each missing permission from template:
   - Emit `role.permission.granted` event

**Canonical Provider Admin Permissions** (27 total):
- **Organization (8)**: `view_ou`, `create_ou`, `update_ou`, `delete_ou`, `deactivate_ou`, `reactivate_ou`, `view`, `update`
- **Client (4)**: `create`, `view`, `update`, `delete`
- **Medication (5)**: `create`, `view`, `update`, `delete`, `administer`
- **Role (4)**: `create`, `view`, `update`, `delete`
- **User (6)**: `create`, `view`, `update`, `delete`, `role_assign`, `role_revoke`

**Events Emitted**:
- `role.created` (1, if role doesn't exist)
- `role.permission.granted` (0-27, depending on existing permissions)

**Returns**: `{ roleId: string, permissionsGranted: number, roleAlreadyExisted: boolean }`

**Scope Path**:
- Uses `subdomain` if provided (e.g., "acme-health")
- Falls back to sanitized org name: `name.toLowerCase().replace(/[^a-z0-9_]/g, '_')`

---

### Phase 2: Configure DNS (Conditional)

**Condition**: Only runs if `subdomain` is provided

**Activities**: `configureDNS`, `verifyDNS`

**DNS Configuration Actions** (`configureDNS`):
1. Check if CNAME record exists (idempotency via Cloudflare API `listRecords`)
2. If exists, emit `organization.subdomain.dns_created` and return existing record ID
3. If not exists:
   - Create CNAME record: `{subdomain}.{PLATFORM_BASE_DOMAIN}` → `{TARGET_DOMAIN}`
   - Set `proxied: true` for Cloudflare Tunnel routing
   - Set `ttl: 1` (auto TTL when proxied)
   - Emit `organization.subdomain.dns_created` event

**DNS Verification Actions** (`verifyDNS`):
1. Query 4 public DNS servers: Google (8.8.8.8, 8.8.4.4), Cloudflare (1.1.1.1, 1.0.0.1)
2. Require quorum: at least 3 servers must return CNAME record
3. If quorum achieved:
   - Emit `organization.subdomain.verified` event
4. If quorum failed:
   - Throw error to trigger DNS retry loop

**DNS Retry Strategy**:
- 7 retry attempts with exponential backoff
- Initial delay: 10 seconds
- Backoff coefficient: 2x
- Max delay: 5 minutes
- Total max time: ~20 minutes
- Retry loop includes both DNS creation and verification

**Events Emitted**:
- `organization.subdomain.dns_created` (1)
- `organization.subdomain.verified` (1, after verification succeeds)

**Returns**: `{ fqdn: string, recordId: string }`

**Skip Condition**:
- No subdomain provided
- Organization type is `platform_owner`
- Partner type is `family` or `court` (stakeholder partners)

---

### Phase 3: Generate Invitations

**Activity**: `generateInvitations`

**Actions**:
1. For each user in `params.users`:
   - Check if invitation exists (idempotency via RPC `get_invitation_by_org_and_email`)
   - If exists, return existing invitation
   - If not exists:
     - Generate UUID for invitation ID
     - Generate secure token (32 bytes, base64url)
     - Calculate expiration (7 days from now)
     - Look up `contact_id` from `contactsByEmail` map (for contact-user linking)
     - Emit `user.invited` event with token, expiration, and optional `contact_id`

**Security**:
- Tokens are cryptographically secure (256 bits)
- Tokens expire after 7 days
- Each token can only be used once

**Events Emitted**:
- `user.invited` (1 per user)

**Returns**: `Array<Invitation>` where:
```typescript
interface Invitation {
  invitationId: string
  email: string
  token: string
  expiresAt: Date
  contactId?: string                    // If user is also a contact
}
```

---

### Phase 4: Send Invitation Emails

**Activity**: `sendInvitationEmails`

**Actions**:
1. For each invitation:
   - Construct invitation URL: `{frontendUrl}/accept-invitation?token={token}`
   - Send email via Resend API (primary) or SMTP (fallback)
   - On success: emit `user.invitation.sent` event
   - On failure: log error, continue to next invitation

**Email Provider Selection**:
- **Primary**: Resend API (recommended, better deliverability)
- **Fallback**: SMTP (if Resend unavailable or configured)
- **Development**: Logging provider (console logs instead of real emails)

**Email Template**:
- Subject: "You're invited to join {orgName} on A4C Platform"
- Body: Personalized invitation with CTA button
- Expiration notice: "This invitation expires in 7 days"

**Events Emitted**:
- `user.invitation.sent` (1 per successful email delivery)

**Returns**: `{ successCount: number, failures: Array<{ email: string, error: string }> }`

**Error Handling**:
- Email failures are **non-fatal** - workflow continues
- Failed email addresses recorded in `result.errors[]`
- Workflow succeeds if at least one email sent successfully

---

### Phase 5: Activate Organization

**Activity**: `emitBootstrapCompletedActivity`

**Actions**:
1. Emit `organization.bootstrap.completed` event with:
   - `bootstrap_id`: Workflow correlation ID
   - `admin_role_assigned`: Role name (e.g., "provider_admin")
   - `permissions_granted`: Count from Phase 1.5
   - `ltree_path`: Org hierarchy path

**Event Handler** (`handle_bootstrap_completed`):
```sql
UPDATE organizations_projection
SET is_active = true,
    activated_at = NOW(),
    updated_at = NOW()
WHERE id = p_event.stream_id;
```

**Events Emitted**:
- `organization.bootstrap.completed` (1)

**Result**: Organization is marked as active and ready for use.

---

## Compensation Flow (Failure Path)

If any phase fails, the workflow enters the compensation flow. Compensation runs in **reverse order** (Saga pattern) to undo completed steps.

### Compensation Order

```
FAILURE DETECTED
     ↓
Emit organization.bootstrap.failed (BEFORE compensation)
     ↓
Phase 4 compensation: Revoke invitations (if generated)
     ↓
Phase 2 compensation: Remove DNS record (if configured)
     ↓
Phase 1 compensation: Delete phones → addresses → contacts
     ↓
Phase 1 compensation: Deactivate organization (safety net)
```

### Compensation Activity Details

#### 1. Emit Bootstrap Failure Event

**Activity**: `emitBootstrapFailedActivity`

**Timing**: Called **first** in catch block, before any compensation

**Purpose**: Record failure for audit trail, even if compensation fails

**Actions**:
1. Determine failure stage from workflow state:
   - `organization_creation`: Failed before org created
   - `dns_provisioning`: Failed during DNS configuration
   - `admin_user_creation`: Failed during invitation generation
   - `invitation_email`: Failed during email sending
   - `role_assignment`: Failed during activation
2. Emit `organization.bootstrap.failed` event with stage and error message

**Event Handler** (`handle_bootstrap_failed`):
```sql
UPDATE organizations_projection
SET is_active = false,
    deactivated_at = NOW(),
    updated_at = NOW()
WHERE id = p_event.stream_id;
```

**Events Emitted**:
- `organization.bootstrap.failed` (1)

**Error Handling**: If event emission fails, log error and continue compensation (don't fail the catch block)

---

#### 2. Revoke Invitations

**Activity**: `revokeInvitations`

**Condition**: Only runs if invitations were generated (`state.invitations.length > 0`)

**Actions**:
1. Query all pending invitations for organization (via RPC)
2. For each invitation:
   - Emit `user.invitation.revoked` event
   - Handler updates `invitations_projection`: `status = 'revoked'`

**Events Emitted**:
- `user.invitation.revoked` (1 per invitation)

**Returns**: Count of revoked invitations

**Error Handling**: Non-fatal - log error but don't fail workflow

---

#### 3. Remove DNS Record

**Activity**: `removeDNS`

**Condition**: Only runs if DNS was configured (`state.dnsConfigured && params.subdomain`)

**Actions**:
1. Find DNS zone via Cloudflare API
2. List CNAME records matching FQDN
3. If record found:
   - Delete record via Cloudflare API
   - Emit `organization.dns.removed` event with status `DELETED`
4. If record not found:
   - Emit `organization.dns.removed` event with status `NOT_FOUND`

**Events Emitted**:
- `organization.dns.removed` (1, with status: `DELETED`, `NOT_FOUND`, or `ERROR`)

**Error Handling**: Non-fatal - log error, emit event with `ERROR` status, return true

---

#### 4. Delete Phones

**Activity**: `deletePhones`

**Condition**: Only runs if organization was created (`state.orgCreated`)

**Actions**:
1. Query all phones for organization (via RPC)
2. For each phone:
   - Emit `phone.deleted` event
   - Handler removes phone from `phones_projection`

**Events Emitted**:
- `phone.deleted` (1 per phone)

**Error Handling**: Non-fatal - log error but don't fail workflow

---

#### 5. Delete Addresses

**Activity**: `deleteAddresses`

**Condition**: Only runs if organization was created (`state.orgCreated`)

**Actions**:
1. Query all addresses for organization (via RPC)
2. For each address:
   - Emit `address.deleted` event
   - Handler removes address from `addresses_projection`

**Events Emitted**:
- `address.deleted` (1 per address)

**Error Handling**: Non-fatal - log error but don't fail workflow

---

#### 6. Delete Contacts

**Activity**: `deleteContacts`

**Condition**: Only runs if organization was created (`state.orgCreated`)

**Actions**:
1. Query all contacts for organization (via RPC)
2. For each contact:
   - Emit `contact.deleted` event
   - Handler removes contact from `contacts_projection`

**Events Emitted**:
- `contact.deleted` (1 per contact)

**Error Handling**: Non-fatal - log error but don't fail workflow

---

#### 7. Deactivate Organization (Safety Net)

**Activity**: `deactivateOrganization`

**Condition**: Always runs if organization was created (`state.orgCreated`)

**Purpose**: **Safety net** - ensures organization is deactivated even if event emission failed

**Why it exists**:
- `emitBootstrapFailedActivity` (step 1) should set `is_active = false` via event handler
- If event emission itself fails (event system broken), the projection won't update
- This activity provides a direct-write fallback to prevent zombie organizations

**Actions**:
1. Check current status: query `organizations_projection.is_active`
2. If already deactivated (`is_active = false` AND `deleted_at` set), return true
3. If still active, direct-update projection:
   ```sql
   UPDATE organizations_projection
   SET is_active = false,
       deactivated_at = NOW(),
       deleted_at = NOW(),
       updated_at = NOW()
   WHERE id = p_org_id;
   ```

**CQRS Exception**:
- This is an **intentional CQRS exception**
- Direct-writes to projection without emitting event
- Justified because: if event emission is broken, emitting another event would also fail
- Logged as "Safety net: organization deactivated via direct write"

**Events Emitted**: None (intentionally)

**Error Handling**: Non-fatal - log error but always return true (never fail compensation)

---

## Domain Events Emitted

### Forward Flow Events

| Event Type | Count | Emitted By | Handler Effect |
|------------|-------|------------|----------------|
| `organization.created` | 1 | `createOrganization` | Creates record in `organizations_projection` |
| `contact.created` | 1-N | `createOrganization` | Creates records in `contacts_projection` |
| `phone.created` | 0-N | `createOrganization` | Creates records in `phones_projection` |
| `email.created` | 0-N | `createOrganization` | Creates records in `emails_projection` |
| `address.created` | 0-N | `createOrganization` | Creates records in `addresses_projection` |
| `organization.contact.linked` | 1-N | `createOrganization` | Creates junction in `organization_contacts` |
| `organization.phone.linked` | 0-N | `createOrganization` | Creates junction in `organization_phones` |
| `organization.email.linked` | 0-N | `createOrganization` | Creates junction in `organization_emails` |
| `organization.address.linked` | 0-N | `createOrganization` | Creates junction in `organization_addresses` |
| `contact.phone.linked` | 0-N | `createOrganization` | Creates junction in `contact_phones` |
| `contact.email.linked` | 0-N | `createOrganization` | Creates junction in `contact_emails` |
| `contact.address.linked` | 0-N | `createOrganization` | Creates junction in `contact_addresses` |
| `role.created` | 1 | `grantProviderAdminPermissions` | Creates record in `roles_projection` |
| `role.permission.granted` | 0-27 | `grantProviderAdminPermissions` | Creates junction in `role_permissions` |
| `organization.subdomain.dns_created` | 0-1 | `configureDNS` | Updates `subdomain_dns_record_id` |
| `organization.subdomain.verified` | 0-1 | `verifyDNS` | Updates `subdomain_verified_at` |
| `user.invited` | 1-N | `generateInvitations` | Creates records in `invitations_projection` |
| `user.invitation.sent` | 1-N | `sendInvitationEmails` | Updates `sent_at` timestamp |
| `organization.bootstrap.completed` | 1 | `emitBootstrapCompletedActivity` | Sets `is_active = true` |

### Compensation Flow Events

| Event Type | Count | Emitted By | Handler Effect |
|------------|-------|------------|----------------|
| `organization.bootstrap.failed` | 1 | `emitBootstrapFailedActivity` | Sets `is_active = false` |
| `user.invitation.revoked` | 0-N | `revokeInvitations` | Updates `status = 'revoked'` |
| `organization.dns.removed` | 0-1 | `removeDNS` | Updates `subdomain_dns_record_id = NULL` |
| `phone.deleted` | 0-N | `deletePhones` | Soft-deletes from `phones_projection` |
| `address.deleted` | 0-N | `deleteAddresses` | Soft-deletes from `addresses_projection` |
| `contact.deleted` | 0-N | `deleteContacts` | Soft-deletes from `contacts_projection` |

**Event Metadata**: All events include:
- `correlation_id`: Business transaction ID (from `params.tracing.correlationId`)
- `trace_id`: Request trace ID (from `params.tracing.traceId`)
- `workflow_id`: Temporal workflow ID
- `activity_name`: Activity that emitted the event

---

## Activity Details

### Activity Retry Policies

All activities use the default retry policy:

```typescript
{
  startToCloseTimeout: '10 minutes',
  retry: {
    maximumAttempts: 3,
    initialInterval: '1s',
    backoffCoefficient: 2,
    maximumInterval: '30s'
  }
}
```

**Exception**: DNS configuration has workflow-level retry (7 attempts) in addition to activity retries.

### Activity Idempotency

All activities implement **check-then-act** pattern:

1. **Check**: Query if operation already completed
2. **Act**: Only perform operation if not already done
3. **Emit**: Always emit event (event_id deduplication handles retries)

**Example** (`createOrganization`):
```typescript
// Check if organization exists
const existing = await supabase
  .schema('api')
  .rpc('check_organization_by_slug', { p_slug: params.subdomain });

if (existing) {
  return { orgId: params.organizationId, contactsByEmail: {} };
}

// Create organization via event
await emitEvent({ event_type: 'organization.created', ... });
```

### Activity Logging

All activities use structured logging:

```typescript
log.info('Starting organization creation', {
  displayName,
  organizationId: params.organizationId,
  mode: params.bootstrapContacts ? 'bootstrap' : 'legacy'
});
```

**Log Levels**:
- `debug`: Detailed execution steps
- `info`: Major milestones (start, completion, counts)
- `warn`: Non-fatal issues (email failures, missing contact_ref)
- `error`: Fatal errors (propagate to Temporal)

---

## Idempotency Strategy

The bootstrap workflow implements **three-layer idempotency**:

### Layer 1: Workflow ID

```typescript
// Client ensures unique workflow ID
const workflowId = `org-bootstrap-${subdomain}`;
await client.workflow.start(organizationBootstrapWorkflow, {
  workflowId,  // Prevents duplicate workflow executions
  taskQueue: 'bootstrap',
  args: [params]
});
```

**Effect**: Prevents duplicate workflow executions for the same organization.

### Layer 2: Activity Check-Then-Act

Each activity checks if work is already done:

```typescript
// Example: createOrganization
const existing = await checkIfExists(params);
if (existing) {
  return existing;  // Already created, return existing
}
await createNew(params);  // Create if not exists
```

**Effect**: Safe to retry activities without creating duplicates.

### Layer 3: Event Deduplication

Database prevents duplicate event processing:

```sql
-- Unique constraint on domain_events
CONSTRAINT domain_events_unique_stream_event
UNIQUE (stream_id, event_type, created_at)
```

**Effect**: Duplicate events are silently ignored via `ON CONFLICT DO NOTHING`.

---

## DNS Retry Strategy

DNS configuration has a **workflow-level retry loop** due to propagation delays:

### Retry Configuration

```typescript
const dnsRetryConfig = {
  baseDelayMs: 10000,       // 10 seconds initial delay
  maxDelayMs: 300000,       // 5 minutes max delay
  maxAttempts: 7            // 7 attempts total
};
```

### Retry Schedule

| Attempt | Delay | Cumulative Time |
|---------|-------|-----------------|
| 1 | 0s | 0s |
| 2 | 10s | 10s |
| 3 | 20s | 30s |
| 4 | 40s | 70s |
| 5 | 80s | 150s |
| 6 | 160s | 310s |
| 7 | 300s (capped) | 610s |

**Total Max Time**: ~20 minutes (including activity execution time)

### What Gets Retried

The retry loop includes:
1. DNS record creation (`configureDNS`)
2. DNS propagation verification (`verifyDNS`)

**Rationale**: DNS records may take several minutes to propagate. The workflow sleeps between retries to allow propagation, then verifies before proceeding.

### Verification Quorum

`verifyDNS` queries 4 public DNS servers and requires **3 of 4** to return the CNAME record:

- **Google**: 8.8.8.8, 8.8.4.4
- **Cloudflare**: 1.1.1.1, 1.0.0.1

**Why quorum**: Protects against:
- Single server cache misses
- Transient network failures
- Regional propagation delays

---

## Safety Net Pattern

The `deactivateOrganization` activity serves as a **safety net** for the event-driven deactivation:

### Normal Path (Event-Driven)

```
Workflow fails
     ↓
Emit organization.bootstrap.failed event
     ↓
Event handler sets is_active = false
     ↓
Organization deactivated
```

### Safety Net Path (Direct Write)

```
Workflow fails
     ↓
Emit organization.bootstrap.failed event
     ↓
❌ Event emission fails (e.g., database connection lost)
     ↓
deactivateOrganization activity runs
     ↓
Direct UPDATE to organizations_projection
     ↓
Organization deactivated (fallback)
```

### CQRS Exception Justification

This is an **intentional CQRS exception**:

**Normal CQRS**: All writes via events → handlers update projections

**Exception**: When the event system itself is broken, emitting another event would also fail

**Justification**:
- **Critical**: Prevents zombie organizations (marked active but failed bootstrap)
- **Rare**: Only runs when event emission has already failed
- **Logged**: Clearly marked as "Safety net: deactivated via direct write"
- **Redundant**: Usually a no-op because event handler already ran

**Alternative Considered**: Don't have safety net, rely on event-driven path
- **Risk**: If event emission fails, organization remains active forever
- **Audit**: Even with safety net, failure is recorded in domain_events (if emission succeeds) or workflow history (if emission fails)

---

## Error Handling

### Transient Errors (Retried)

Temporal automatically retries these errors:

- Network timeouts
- Database connection errors
- External API rate limits
- DNS propagation delays

**Retry Policy**: 3 attempts with exponential backoff (10s, 20s, 40s)

### Permanent Errors (Non-Retryable)

These errors fail immediately:

- Invalid input parameters
- Missing required fields
- Subdomain already exists
- Email address already invited

**Implementation**: Use `ApplicationFailure.create({ nonRetryable: true })` in activities.

### Non-Fatal Errors (Logged)

These errors don't fail the workflow:

- Email delivery failures (at least one must succeed)
- Compensation errors (logged in `result.errors[]`)

### Error Propagation

```
Activity throws error
     ↓
Temporal retries (up to 3 attempts)
     ↓
If retries exhausted, error propagates to workflow
     ↓
Workflow catch block executes
     ↓
Emit bootstrap.failed event
     ↓
Run compensation activities
     ↓
Return failure result (not throw)
```

**Important**: Workflow **returns** failure result, not **throws**. This prevents Temporal from retrying the entire workflow.

---

## Example Usage

### Starting the Workflow

```typescript
import { Client } from '@temporalio/client';
import { organizationBootstrapWorkflow } from './workflows/organization-bootstrap';

const client = new Client({
  connection: { address: 'temporal.example.com:7233' }
});

// Start workflow with unique ID
const handle = await client.workflow.start(organizationBootstrapWorkflow, {
  workflowId: `org-bootstrap-acme-health`,  // Unique per organization
  taskQueue: 'bootstrap',
  args: [{
    organizationId: '550e8400-e29b-41d4-a716-446655440000',  // Pre-generated
    subdomain: 'acme-health',
    orgData: {
      name: 'ACME Health Services',
      type: 'provider',
      bootstrapContacts: [{
        temp_id: 'contact-1',
        first_name: 'John',
        last_name: 'Doe',
        email: 'john@acme-health.com',
        type: 'a4c_admin',
        label: 'Primary Contact'
      }],
      bootstrapAddresses: [{
        temp_id: 'address-1',
        street1: '123 Main St',
        city: 'Austin',
        state: 'TX',
        zip_code: '78701',
        type: 'physical',
        label: 'Headquarters',
        contact_ref: 'contact-1'
      }],
      bootstrapPhones: [{
        temp_id: 'phone-1',
        number: '512-555-1234',
        type: 'office',
        label: 'Main Office',
        contact_ref: 'contact-1'
      }],
      bootstrapEmails: [{
        temp_id: 'email-1',
        address: 'info@acme-health.com',
        type: 'work',
        label: 'General Inquiries'
      }]
    },
    users: [
      {
        email: 'john@acme-health.com',
        firstName: 'John',
        lastName: 'Doe',
        role: 'provider_admin'
      },
      {
        email: 'jane@acme-health.com',
        firstName: 'Jane',
        lastName: 'Smith',
        role: 'clinician'
      }
    ],
    frontendUrl: 'https://a4c.firstovertheline.com',
    tracing: {
      correlationId: 'bootstrap-20260210-123456',
      traceId: 'trace-abc123'
    }
  }]
});

console.log(`Workflow started: ${handle.workflowId}`);
```

### Polling for Status

```typescript
// Poll workflow status
const result = await handle.result();

if (result.errors.length === 0) {
  console.log('✅ Bootstrap succeeded');
  console.log(`Organization ID: ${result.orgId}`);
  console.log(`Domain: ${result.domain}`);
  console.log(`Invitations sent: ${result.invitationsSent}`);
} else {
  console.log('❌ Bootstrap failed or partial failure');
  console.log(`Errors: ${result.errors.join(', ')}`);
}
```

### Querying Workflow State (Before Completion)

```typescript
// Query workflow state while running
const state = await handle.query<WorkflowState>('getState');

console.log(`Organization created: ${state.orgCreated}`);
console.log(`DNS configured: ${state.dnsConfigured}`);
console.log(`Invitations sent: ${state.invitationsSent}`);
```

---

## Related Documentation

### Architecture & Design
- **[Temporal Overview](../../architecture/workflows/temporal-overview.md)** - Workflow orchestration architecture
- **[Organization Onboarding Workflow](../../architecture/workflows/organization-onboarding-workflow.md)** - Business workflow design
- **[Event Sourcing Overview](../../architecture/data/event-sourcing-overview.md)** - CQRS architecture patterns

### Implementation Guides
- **[Error Handling and Compensation](./error-handling-and-compensation.md)** - Saga pattern implementation
- **[Activities Reference](../reference/activities-reference.md)** - Complete activity catalog
- **[Resend Email Provider](./resend-email-provider.md)** - Email configuration

### Database & Infrastructure
- **[Event Handler Pattern](../../infrastructure/patterns/event-handler-pattern.md)** - Event processing architecture
- **[Event-Driven Architecture](../../infrastructure/guides/supabase/docs/EVENT-DRIVEN-ARCHITECTURE.md)** - Backend event sourcing spec
- **[RBAC Architecture](../../architecture/authorization/rbac-architecture.md)** - Role-based access control

### Operations
- **[Workflows CLAUDE.md](../../../workflows/CLAUDE.md)** - Development guidelines
- **[Infrastructure CLAUDE.md](../../../infrastructure/CLAUDE.md)** - Deployment procedures

---

**End of Document**
